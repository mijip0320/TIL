# Java 정리

### JVM(Java Virtual Machine)

* 자바 가상 머신(가상머신: 프로그램의 실행하기 위해 물리적 머신과 유사한 머신의 소프트웨어로 구현.)
* JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행.
* JAVA와 OS 사이의 중개자  역할을 하면서 JAVA가 OS의 환경에 구애받지 않고 재사용이 가능하게 해줌.
* 효율적인 메모리 관리, Garbage Collection 수행
* JVM은 스택기반의 가상머신



#### 자바프로그램 실행과정

> 1. 프로그램 실행 -> JVM은 OS로부터 프로그램이 필
>
> 2. 요로 하는 메모리를 할당받음
>
>    (용도에 따라 여러 영역으로 나누어 관리)
>
> 3. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환.
>
> 4. Class Loader를 통해 class 파일들을 JVM으로 로딩
>
> 5. 로딩된 class 파일들을 exe engine을 통해 해석
>
> 6. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 됨.
>
> 7. JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업 수행.



#### JVM 구성

##### Class Loader

* JVM내로 클래스 로드, 링크를 통해 배치하는 작업을 수행하는 모듈
* 런타임 시 동적으로 클래스 로드
* 자바는 동적 코드(컴파일 타임이 아니라 런타임에 참조)



##### Execution Engine(실행 엔진)

* 클래스를 실행시키는 역할
* 클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드 배치, 실행엔진에 의해 실행됨
* 자바 바이트코드는 인간이 보기 편한 형태로 기술됨, 그래서 기계가 실행 할 수 있는 형태로 JVM이 내부적으로 바꿔줌
  * Interpreter: 자바 바이트코드를 명령어 단위로 읽어서 실행(단점: 수행이 느림)
  * JIT(Just-In-Time): Interpereter의 단점 보완, 적절한 시점에 바이트코드 전체를 컴파일하여 native code로 변경 후 native code로 직접 실행 
    * natvic code는 캐시에 보관되어 빠르게 수행됨
    * JIT 컴파일러가 컴파일하는 과정은 Interpreting보다 오래 걸려서 한번만 실행되는 코드는 컴파일 하지 않고 Interpreting하는 것이 유리!



#### Garbage Collector

> GC를 수행하는 모듈 = 쓰레드



#### Runtime Data Area

1. PC Register

   > - Thread가 시작 될 때 생성됨
   > - Thread가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분(JVM 명령의 주소를 가짐)

2. JVM 스택 영역

   > - 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하는 영역
   > - 임시 데이터, 변수, 스레드, 메소드 정보 저장
   > - 메소드 호출 할때마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성, 수행 끝나면 프레임별로 삭제
   > - 메소드 안 local variable들을 저장, 매개변수, 리턴 값, 연산된 값들 임시로 저장

3. Native method stack

   > - 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
   > - JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간
   > - JAVA Native Interface를 통해 바이트코드로 전환, 저장

4. Method Area(=Class area / Static area)

   > - 클래스 정보를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장하기 위한 메모리 공간**. 
   > - 클래스 데이터를 위한 공간
   > - main 메소드의 호출에서부터 계속된 메소드의 호출로 흐름을 이어감

5. Heap 영역

   > - 객체를 저장하는 가상 메모리 공간, **new** 연산자로 생성된 객체와 배열을 저장
   > - 힙 영역은 New/Young Generation, Tenured Generation, Permanent Generation으로 나뉨
   >   - Permanent Generation
   >     - 생성된 객체들의 정보의 주소값이 저장된 공간
   >     - Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용됨.
   >     - Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용
   >     - Spring Framework(Reflection 자주 사용) 이용할 경우 이 영역에 대한 고려 필요
   >   - New/Young 영역
   >     - **Eden**: 객체들이 최초로 생성되는 공간
   >     - **Survivor 0 / 1**: Eden에서 참초되는 객체들이 저장되는 공간
   >   - Old 영역
   >     - New Area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간 Eden 영역에 객체가 가득차게 되면 첫 번째 GC(minor GC)가 발생



### Collection

- List,Map,Set, Stack, Queue 인터페이스를 기준으로 여러 구현체 존재

- 사용 이유? 다수의 Data를 다루는데 표준화된 클래스들을 제공, Datastructure 직접 구현 필요 x

- 배열이 가진 고정 크기의 단점을 극복하기 위해 객체들을 쉽게 삽입, 삭제, 검색할 수 있는 가변 크기의 (Container)

- Generics라는 기법으로 만들어져있음.

- 컬렉션 클래스 이름에는 `<E>`,`<K>`,`<V>`와 같은 타입 매개 변수를 가짐

  - 타입매개변수는 `Integer`와 같이 구체적인 타입을 지정하면 정수값만 저장하는 클래스 형태이다
  - `<E>` : 특정 타입만 다루지 않고 여러 종류의 타입으로 변신 가능하도록 일반화 -> **Generic Type**

- 상황에 따라 객체의 수를 동적으로 정할 수 있음
  - List: `ArrayList`,` Linked List`, `Vector`
  
    - ```java
      ArrayList<String> a = new ArrayList<>();
      a.add("Hello");
      String str = a.get(0);
      int len = a.size();
      a.remove(0);
      ```
  
  - Iterator<E>
  
    - ```java
      List<MyDate> dateList = new ArrayList<>();
      		dateList.add(new MyDate(2020,11,30));
      		dateList.add(new MyDate(2020,9,2));
      		dateList.add(new MyDate(2020,11,30));
      
      Iterator<MyDate> iterator = dateList.iterator();
      		
      		MyDate date = null;
      		while(iterator.hasNext()) { //iterator가 다음에 가져 올 요소가 있을 경우
      			date = iterator.next();
      			System.out.println(date);
      		}
      ```
  
  - Map: `HashMap`(key-value 형태), `LinkedHashMap`(key에 대한 순서 보장)
  - Set: `HashSet`(value에 대해서 중복 값 저장 x, `Map`의 key-value 구조에서 key 대신에 value가 들어가 value를 key로 하는 자료구조), `LinkedHashSet`(순서 보장)
  - Stack과 Queue: `stack`은 new로 생성, `Queue`는 `LinkedList`에 new 이용



### Generic

- 제네릭은 모든 종류의 타입을 다룰 수 있도록 클래스나 메소드를 타입 매개변수를 이용하여 선언하는 기법
  - C++의 템플릿과 동일
  - 자바의 제네릭은 클래스 코드를 찍어내듯이 생산할 수 있도록 일반화(generic) 시키는 도구
- 제네릭은 자바에서 안정성을 맡고 있음
- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능 ->안정성을 높이고 형변환의 번거로움을 줄여줌, 코드도 간결해줌
- api를 설계하는데 있어서 보다 명확한 의사 전달 가능



### 오버라이딩(재정의) vs 오버로딩(다중정의)

|                      Overriding(재정의)                      | Overloading(다중정의)                                        |
| :----------------------------------------------------------: | ------------------------------------------------------------ |
| 메소드를 하위 클래스에서 (재)정의<br />- 오버라이딩 = '슈퍼 클래스 메소드 무시하기 혹은 덮어쓰기' => **동적 바인딩** 유발<br />- 오버라이딩은 상속을 통해 '하나의 인터페이스(같은 이름)에 서로 다른 내용 구현이라는 객체 지향의 다형성을 실현하는 도구' | 메소드를 같은 클래스에서 정의                                |
| - 메소드 이름 동일<br />-Parameter(개수 및 데이터 타입) 동일<br />-Return 타입 동일 | - 메소드 이름 동일<br />-Parameter(개수 및 데이터 타입) 동일<br />-Return 타입이 다를 수 있음 |
| 접근 제한자: 하위 메소드의 접근 범위가 상위 메소드의 접근 점위 보다 넓거나 같아야 한다. | 접근 제한자: 관계없음                                        |
| 예외 처리: 예외 발생시 같은 예외 형식이거나, 더 구체적인 예외 형식이어야 한다. | 예외 처리: 관계 없음                                         |



### Access Modifier

변수 또는 메소드의 접근 범위 설정

- public(+): 어떤 클래스에서라도 접근 가능
- protected(#): 해당 패키지 내 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근 가능
- default: 같은 디렉토리(같은 package)내의 다른 클래스에서 참조 가능
- private(-): 클래스 내부에서만 참조 가능



### 추상 클래스

> 추상 메소드란 선언은 되어 있으나 코드가 구현되어 있지 않은, 즉 껍데기만 있는 메소드(abstract 키워드 이용)

- 추상클래스로 되는 경우

  - ```java
    //추상 메소드를 포함한 클래스
    abstract class Shape{ //추상 클래스 선언
    	public Shape(){ }
    	public void paint() { draw(); }
    	abstract public void draw(); //추상 메소드 선언
    }
    ```

  - ```java
    //추상 메소드가 없지만 abstract로 선언한 클래스
    abstract class MyComponent{ //추상 클래스 선언
        String name;
        public void load(String name){
            this.name = name;
        }
    }
    ```

  - ```java
    //오류. 추상 메소드가 존재하지만 추상 클래스로 선언되지 않음
    class Fault{
    	abstract public void f();//추상 메소드
    }
    ```

- 추상 클래스에는 객체 생성이 불가, 생성자 및 메소드 정의 가능

- 추상 클래스를 단순히 상속받는 서브 클래스는 추상 클래스가 됨(추상 클래스의 추상 메소드를 그대로 상속받기 때문).

- 추상 클래스의 구현: 슈퍼 클래스에 선언된 모든 추상 메소드를 서브 클래스에서 오버라이딩하여 실행 가능한 코드로 구현하는 것

- 추상 클래스의 용도:

  - 추상 클래스를 상속받은 서브 클래스는 개발자에 따라 다양하게 구현됨
  - 추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업이 쉬워짐
  - 추상 클래스는 *계층적 상속 관계*를 가지는 클래스들의 구조를 만들 때 적합



### 인터페이스

> 정의: 인터페이스는 서로 다른 하드웨어 장치들이 상호 데이터를 주고 받을 수 있는 규격을 의미

- 자바의 인터페이스는 interface 키워드를 사용하여 클래스를 선언하듯이 선언.

- 인터페이스 구성:

  - 상수와 추상 메소드(추상 메소드는 public abstract 부분 생략 가능)
  - default(public) 메소드
  - private 메소드
  - static 메소드
  - 필드(멤버 변수) **생성 불가**

- 인터페이스는 객체 생성 불가

- 인터페이스 타입의 레퍼런스 변수 선언 가능

- 인터페이스끼리 (다중)상속 가능

  - ```java
    interface A extends B{
    	//추상 메소드 선언
    }
    ```

  - ```java
    interface A extends B,c{
    	//추상 메소드 선언
    }
    ```

- 인터페이스를 상속받아 클래스를 작성하면 인터페이스의 모든 추상 메소드를 구현해야함

- 인터페이스 상속 방법:

  - ```java
    class A implements Binterface {
    	//Binterface의 모든 추상 메소드 구현
    	//(선택) 메소드 추가 작성
    }
    ```



### 인터페이스 VS 추상 클래스 비교

| 비교        |                             목적                             | 구성                                                         |
| ----------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 추상 클래스 | 추상 클래스는 서브 클래스에서 필요로 하는 대부분의 기능을 구현하여 두고 서브 클래스가 상속받아 활용할 수 있도록 하되, 서브 클래스에서 구현할 수밖에 없는 기능만을 추상 메소드로 선언하여, 서브 클래스에서 구현하도록 하는 목적(다형성) | - 추상 메소드와 일반 메소드 모두 포함<br />- 상수, 변수 필드 모두 포함 |
| 인터페이스  | 인터페이스는 객체의 기능을 모두 공개한 표준화 문서와 같은 것으로, 개발자에게 인터페이스를 상속받는 클래스의 목적에 따라 인터페이스의 모든 추상 메소드를 만들도록 하는 목적(다형성) | - 변수 필드(멤버 변수)는 포함하지 않음<br />- 상수, 추상 메소드, 일반 메소드, default 메소드, static 메소드 모두 포함<br />- protected 접근 지정 선언 불가<br />-다중 상속 지원 |



### Static 멤버

- static 멤버는 객체를 생성하지 않고도 사용할 수 있는 멤버이다.
- 클래스당 하나만 생성되는 멤버로서 동일한 클래스의 모든 객체들이 공유
- 클래스당 하나씩 생성되어 클래스 멤버라고 부름
- 객체.staticfield, 객체.static메소드, 클래스명.static멤버 형식으로 호출
- 공유 멤버를 만들고자 할 때 활용
- static 메소드는 static 멤버만 접근 가능
- non-static 멤버는 객체가 생길 때 객체마다 생기며, 다른 객체들과 공유하지 않음
  - 객체가 사라지면 non-static 멤버도 함께 사라지고 더 이상 접근 불가
  - 각 객체마다 하나씩 생겨 인스턴스 멤버라고 부름



### 객체 지향

> 객체들은 자신만의 고유한 특성(state)과 행동(behavior)을 가지며 다른 객체들에게 행동을 요청하거나 정보를 주고받는 등 상호 작용하면서 존재

1. 캡슐화(Encapsulation): 

   - 객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게하는 것으로 객체의 가장 본질적인 특징
   - 객체는 캡슐화가 기본 원칙이지만 외부와의 접속을 위해 몇 부분만 공개 노출함.
   - 객체는 **클래스(캡슐)**,**필드(멤버 변수)**,**메소드(멤버 함수)**로 구성

2. 상속(Inheritance):

   - 상위 개체의 속성이 하위 개체에 물려져서, 하위 개체가 상위 개체의 속성을 모두 가지는 관계

   - 부모: super class, 자식: sub class

   - ```java
     //상속 선언
     class ColorPoint extends Point{
     	...
     }
     ```

   - ```java
     //서브 클래스 객체
     Point p = new Point();
     ColorPoint cp = new ColorPoint(); //서브 클래스 객체 생성
     ```

   - 자바 상속의 특징

     - 자바에서 다중상속 지원 X

     - 상속의 횟수에 제한을 두지 않음

     - 계층 구조의 최상위에 Object 클래스가 있다.

     - 상속의 장점: 클래스의 간결화, 클래스 관리 용이, 소프트웨어의 생산성 향상

     - 서브 클래스의 객체가 생성되면 이 객체 속에 서브 클래스 멤버와 슈퍼 크래스의 멤버가 모두 들어 있음

       ```java
       //부모의 생성자를 Novel(자식)이 super로 부름
       //부모
       public Publication(){
       		
       }
       	
       public Publication(String title, String publishingDate, int page, int price) {
       		
       		setTitle(title);
       		setPublishingDate(publishingDate);
       		setPage(page);
       		setPrice(price);
       }
       //자식
       public Novel(String title, String publishingDate, int page, int price, String author, String genre) {
       		super(title,publishingDate,page,price);
       		setAuthor(author);
       		setGenre(genre);	
       }
       ```

     - 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자가 실행됨

     - 메소드 오버라이딩 개념

3. 다형성(Polymorphism):

   - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것
   - **오버라이딩**: 슈퍼 클래스에 구현된 메소드를 서브 클래스에서 동일한 이름으로 자신의 특징에 맞게 다시 구현
   - **오버로딩**: 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를 여러개 만듦



### 절차 지향 프로그래밍과 객체 지향 프로그래밍

- 절차 지향 프로그래밍

  > 실행하고자 하는 절차를 정하고, 이 절차대로 프로그래밍하는 방법을 절차 지향 프로그래밍

- 객체 지향 프로그래밍

  > 실제 세상에 가깝게 모델링하여 실제 세상의 물체를 객체로 표현하고, 객체들의 관계, 상호 작용을 설계한 뒤, 각 객체를 클래스로 작성



### 클래스와 객체

- 클래스는 객체를 만들어 내기 위한 설계도 혹은 틀
- 객체는 클래스 모양 그대로 생성된 실체
- 객체를 클래스의 인스턴스



### 스레드

- 스레드: 운영체제나 JVM에서 태스크(작업)을 실행하는 단위, 운영체제나 JVM에 의해 관리되는 단위
- 멀티 프로세싱: 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 기법
  - 각 프로세스는 고유한 메모리 영역을 보유하고 독립적으로 실행
  - 문제점: 프로세스들은 변수 공유 불가 ->오버헤드가 크고 문맥 교환에 따른 과도한 작업량이 문제
- 멀티스레딩: 멀티 프로세싱의 문제점을 개선, 하나의 응용 프로그램을 동시처리가 가능한 여러 작업으로 분할하고 작업의 개수만큼 스레드를 생성하여 각 스레드로 하여금 하나의 작업을 처리하도록 하는 기법
- 자바에는 프로세스가 존재하지 않고 스레드 개졈만 존재
- JVM은 멀티스레딩만 지원
- 자바 스레드: JVM에 의해 스케쥴되는 실행 단위 코드 블록