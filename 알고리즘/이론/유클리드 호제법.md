# 유클리드 호제법

> 두 수의 최대공약수를 구하는 알고리즘
>
> 호제법? 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘을 말함



## 일반적인 최대공약수를 구하는 방법

**소인수분해 필요**

```
1112 = 139 X 2 X 2 X 2
695 = 139 X 5
```

- 하지만 이러한 방법은 수가 커질수록 소인수분해하기 어려워진다는 단점 존재



## 유클리드 호제법 사용하기

💡 유클리드 호제법을 이해하기 위해서는 MOD연산에 대해 알고 있어야 함

> MOD 연산? 두 값을 나눈 나머지를 구하는 연산

1. 큰 수를 작은 수로 나눈 나머지를 구함 = MOD 연산을 함

   ```
   1112 mod 695 = 417
   ```

2. 나눴던 수와 나머지로 또 MOD 연산을 함

   ```
   695 mod 417 = 278
   ```

3. 이 과정을 계속 반복

   ```
   417 mod 278 = 139
   278 mod 139 = 0
   ```

4. 나머지가 0이 되었을 때, 마지막 계산에서 나누는 수로 사용된 `139`가 `1112와 695`의 **최대 공약수가 됨**

:star: 유클리드 호제법은 MOD연산을 반복하면 됨



## 유클리드 호제법 이해하기

1112와 695가 최대공약수 N의 배수이다.

즉, 417, 278, 139 모두 **N의 배수인 수**와 **같은 최대공약수를 가진다는 것**을 알 수 있다.

- 278은 139로 나누어 지고 나머지가 0
- 이때 최대공약수 N이 139라는 것을 알 수 있다.

:star: 유클리드 호제법은 나눗셈만 반복해서 최대공약수를 구할 수 있음

:star: 정해진 순서로 계산하면 효율적!



### 반복문 코드

```java
int GCD(int a, int b){ //조건: a>b일때
	int tmp;
    while(b){ //b가 0이 될 때까지
        tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}
```

### 재귀함수 코드

```java
int GCD(int a, int b){
    return b ? GCD(b, a % b) : a;
}
```

```java
static int GCD(int a, int b){
    if( b == 0 ){
        return a;
    }else{
        return GDC(b, a % b);
    }
}
```



출처: [유클리드 호제법](https://velog.io/@yerin4847/W1-%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C-%ED%98%B8%EC%A0%9C%EB%B2%95)